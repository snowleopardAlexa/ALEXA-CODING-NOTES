1. What is JSX?

A syntax extension of JavaScript created for the React JS framework. JSX is an XML/HTML-like syntax used by React that extends ECMAScript so that XML/HTML-like text can co-exist with JavaScript/React code. Unlike the past, instead of putting JavaScript into HTML, JSX allows us to put HTML into JavaScript.

2. How to navigate Javascript landscape? What technologies are related to JS?

- Vanilla JavaScript
- ES2015
- Babel
- React
- Vue.js
- ECMAScript
- CoffeeScript
- JSX
- TypeScript
- Angular
- ES6
- Node.js
- Gulp
- WebPack 

JS is constantly evolving. 

3. What is the Morten's incomplete guide to navigation the JS landscape?

- JavaScript: the core language; sometimes referred to as vanilla JS or VanillaJS
- ECMAScript: the browser specification of the JS language. It is not the language itself, but official description how the JS should behave. 
- ES6, ES2015, ES2017, Etc: refers to the use of features defined in ECMAScript, but not necessarly supported by modern browsers. --> Using ECMAScript usually means also using Babel.js to make it work in current browser implementations. 
- TypeScript: variation, dialect, or flavor of JS introducing features like strong typing. --> .ts
- React, Vue, Angular: JS frameworks allowsing us to write JS-based front-end applications.
--> introduce new coding conventions like JSX, and reliance on tools like Babel, WebPack, and Node.js.
- npm, WebPack, Gulp: build tools and infrastructure to automate the process of optimizing human-readable JS for the best browser perfromance.
- Node.js: JS server runtime used to run JS everywhere; used to run npm, WebPack, Babel, and more on your computer. 

4. What are the best tools from VSC to format and lint the code?

- Prettier helps automatically clean up your formatting
- ESLint helps automatically detect coding errors and can do basic cleanup automatically
- Both require Node.js

5. Why do you place JS at the beginning in the html document and why sometimes you put it at the end of the html document?

We place JS at the beginning of the html <script>...</script> in the head section, but in many cases, JS is also placed at the end. The code is read from the top to the bottom and once it encounters JS in the head, it will stop reading the code and it means that it will slow down rendering of the other elements. We place JS at the end of the html if it applies to the element that must be rendered before JS will work on it. 

6. What are the benefits of using external JS in the html? How to write the external JS in the head?

<script src="script.js></script>

BENEFITS:
- Separating HTML and JavaScript code will help manage the code base better
- Designers can work along with coders parallel without code conflicts
- Works well with modern source code version control systems such as GIT and SVN.
- Each of these files will maintain history
- Can be checked in, checked out by multiple programmers.
- Code as well as HTML is easily readable
- External JavaScript files are cached by browsers and can speed up page load times
With these small js files, you can use Google closure or YUI Compressor or other minifying tools to reduce the size and make it not readable by humans.
- Many popular JavaScript packages are available as hosted on content delivery networks (cdn) and you can simply point to them using the URL in the src, thus avoiding copying the js file to local folder.
- Take advantage of advanced tools such as CommonJS or RequireJS to load these scripts logically and modularly.

7. What are the cons of JS external?

- The browser has to make an extra http request to get the js code.
- Code can be downloaded using the url of the js file. This can help coders to steal your code easily.
- Dependency: If script1.js relies on script2.js and for some reason the script1.js download fails, then your application will break/crash, though the chances of this happening is very slim.
- Order of these includes must be maintained, otherwise you get into scope errors.
A small change to a common js file may cause unexpected results in some of the HTML files that use this js. Example, if you add document.load() in a common js since a certain HTML1 that uses this common js needs it, that may fix the issue in HTML1 but what about the other HTML files which also happen to include the same js?
- When many HTML pages are using a common js file, you need to be extra careful to change the common js. You will need to test all the HTML files that depend on this common js, every time you make a change to the js file.

8. What are the cons of JS external?

- The browser has to make an extra http request to get the js code.
- Code can be downloaded using the url of the js file. This can help coders to steal your code easily.
- Dependency: If script1.js relies on script2.js and for some reason the script1.js download fails, then your application will break/crash, though the chances of this happening is very slim.
- Order of these includes must be maintained, otherwise you get into scope errors.
A small change to a common js file may cause unexpected results in some of the HTML files that use this js. Example, if you add document.load() in a common js since a certain HTML1 that uses this common js needs it, that may fix the issue in HTML1 but what about the other HTML files which also happen to include the same js?
- When many HTML pages are using a common js file, you need to be extra careful to change the common js. You will need to test all the HTML files that depend on this common js, every time you make a change to the js file.

9. Is moving the script tag to the bottom of html a good practice?

No, it is not.  The traditional solution to this problem is to simply move, the script tag to the end of the document, so the browser only encounters it, when it's rendered everything else. This is not a solution though, this is a hack, and it introduces a whole range of other problems, there's a good chance you have JavaScript that should run at the beginning, or should happen, while the document is being loaded. And doing it this way, would mean you have to just split up the JavaScript depending on what it's doing, and then place some of it at the top, and some on the bottom. It's a really imprecise and hacky way of doing it, and it doesn't really work all that well. For this reason, we now have new tools in JavaScript to tightly control how, and when JavaScript is loaded.

10. What are the async and defer in JS and what is their role in loading JS in the browser?

<script src="js/script.js" async></script>

HTML PARSING --> JS download --> JS execution 
--> HTML parsing

The async keyword changes this behavior significantly. It tells the browser, 'Hey, when you encounter a JavaScript file, keep parsing the HTML while you download the JavaScript file, and only stop the parsing when you actually have the file, then execute whatever's in the JavaScript file, and then continue HTML parsing.' This dramatically shortens the time it takes for the browser to execute everything. And it doesn't, create this huge render blocking issue. There's still a hole in the rendering, but it's much shorter. This is good for some purposes, especially when you need, to get the JavaScript to parse as quickly as possible, and you don't really care about render blocking. But in our circumstance, we need to make sure the browser, only executes the JavaScript, after the document is complete. 

The defer keyword tells the browser, 'parse your HTML and if you encounter JavaScript, just load it alongside your HTML parsing. Then when the HTML parsing is complete, execute whatever JavaScript you have.' So this is exactly what we want for our purposes. That means, I can go back to my script, and then at the end of my script tag, just add defer, save the file, and in the browser, everything is now working properly, because we are literally deferring the execution, off the script until, everything else has been rendered. Here's your takeaway. 

Async and defer should be the standard way of loading JavaScript today. Only use render blocking, meaning ,either placing the script tag without the async and defer keywords, or placing the, script tag at the bottom of the document, if you have a specific reason to do so. And trust me, I've asked around and tried to figure it out myself, I have yet to find a use case, where it makes sense, to not use async and defer. Loading JavaScript in the footer, is now an anti pattern. 

From here on forward, JavaScript should always be loaded in the head, and then you use async or defer, to control when that JavaScript is executed on the document.

11. Do async/defer are the standard to use these days?

Only use render blocking when you have a specific reason. Loading JS in the footer is now an anti-pattern.

12. What are JS modules?

JavaScript modules allow us to break pieces out of a JavaScript file and place them in a separate file and then import them back into the original file again.

13. What are the objects in JS?

This backpack is an object. This object has many identifiable properties like color, size, et cetera. We can give all of these properties recognizable names and then use them to describe this individual backpack objects. This backpack has the color gray. That's a property. If we fill it all the way up, we'll discover its volume is 30 liters. Another property. It has a bunch of pockets, 15 I think, that's a property. It has seven straps as a property, et cetera, et cetera. Object properties define the specifics of this one particular object. That way, I can have several backpacks, and why they're all backpacks, each has its own set of properties which makes that backpack a unique object. Now, I said JavaScript is a prototype based object oriented programming language. That means, each object is a unique instance of an object prototype. I have a lot of backpacks. The reason I can say they're all backpacks is they share common properties which define them as belonging to the backpack category. They all have two straps on one side, I can put my arms through. The area behind those straps is flat so it fits comfortably against my back. And they all have an opening at the top. This properties describe the prototype of a backpack and the particular combination and configuration of these properties define each individual backpack. This object prototype makes it easy to identify an existing bag as a backpack. You can check to see if it has the properties that match the prototype, and makes it easy to create a new backpack. Simply describe it by filling the property values. This prototype based object orientation allows us to do in programming, what we as humans do every time we encounter a new object and catalog it in our minds. We look at it, note its properties and think, this thing has the same collection of properties as this other thing I already know. So even though it is a different thing in appearance, the similarities in properties means its the same object type. And there's more, objects can have features built into them allowing us to change their property values. This backpack has several such features. A lid that can be opened and closed, a zipper to open and close the left and right sides, Strap adjusters to change the strap length, et cetera. In JavaScript, these property changing features inside an object are called methods. Which makes sense if you think about it, there's a method for opening and closing the backpack, a method for lengthening the straps and so on. These methods act on the current object only. So if I open this backpack using its top access method nothing happens to this other backpack because it's an entirely separate object. Oh, and one final thing, objects can contain other objects. So inside this backpack object, there is another object, a headlamp. And because the headlamp object is inside the backpack object, it is quite literally a property of the backpack object for as long as it's in there. This headlamp has its own set of properties, color, size, battery status, et cetera, and has its own set of methods, I can turn the light on and off, I can adjust the strap, I can charge it and so on. The headlamp object like the backpack object is a unique and separate object. It can be included inside another object, or it can be separate. There can be one or many of them and changing one object does not change the others.

const backpack; <-- variable holds data
const backpack = {}; <-- curly brackets define data as an object

const backpack = {
  name: "Coma Backpack", <-- properties defined using key-value pairs.
  volume: 40,
  color: "grey",
  pocketNum: 15,
  strapLength: {
    left: 26,
    right: 26,
},
  lidOpen: false,
  toggleLid: function (lidStatus) <-- methods are properties containing functions.
   this.lidOpen = lidStatus;
  },
};

* this - refers to the current object.

14. What are the objects containers in JS?

const backpack = {
  name: "Coma Backpack",
  volume: 34,
  color: "red",
};

const <-- variable declaration: var, let, const
backpack <-- variable name: refers to the name; get the data contained within

Objects are typically Constants --> we can change the properties of the object inside the container. We can't remove or replace the object from the container.

15. What does it mean objects are typically constants in JS?

We can change the properties of the object inside the container. We can't remove or replace the object from the container.

16. Which keyword do you use to build an object using a constructor function?

new

17. What is the constant in JS?

ES6 provides a new way of declaring a constant by using the const keyword. The const keyword creates a read-only reference to a value. However, variables created by the const keyword are immutable. In other words, you can't reassign them to different values.

18. What are the object properties?

const backpack = {
name: "Coma", <--> properties
volume: 45,
color: "Red"
}

Properties of objects are separated by comma, and named with camelCase. Properties can be changed, added, and deleted, but some are read-only. All properties have a name and a value. The value is one of the properties attributes. In JS all attributes can be read, but only the value attribute can be changed, only if the property is writeable.

19. What is the example of nested objects in JS? Write the code. 

Values in an object can be another object.
You can access nested objects using the dot notation or the bracket notation:

myObj = {
  name: "Alexa",
  age: 34,
  cars: {
    car1: "Ford",
    car2: "BMW",
    car3: "Fiat"
  }
}

myObj.cars.car2;

20. What are nested arrays and objects? Write an example code.

const myObj = {
   name: "Alexa",
   age: 45,
   cars: [
        {name: "Ford", "models":["BMW", "Focus", "Mustang"]},
        {name: "BMW", "models":["320", "x3", "x5"]},
        {name: "Ferrari", "models":["546", "ak345", "Mu678"]},
  ]
}

21. How to access the objects in JS?

Anytime you want to access an object or anything else contained inside a variable you simply call it by its name and JavaScript will hand it to you. JavaScript has a series of console methods for this purpose. And the most common one is called console log. 

console.log(backpack);

22. Arrow functions vs. regular functions, which technique is better and when to use them?

...

23. How to troubleshoot JS?

- using a browser - CONSOLE
- using a browser - SOURCES
- using a browser - DEBUGGER

24. What are the 3 ways to access object properties?

- DOT NOTATION: object.property
- SQUARE BRACKET NOTATION: object['property']
- OBJECT DESTRUCTURING: const {property} = object

25. Explain the dot notation accessor of object property in JS, and its limitations.

const hero {
  name: 'Batman'
  cars: {
    blackCars: 5,
    whiteCars: 2,
  },
};

hero.name
hero.cars.blackCars

Choose the dot property accessor when the property name is known AHEAD OF TIME
   
Limitations:
- It’s a lot easier to read
- It’s way faster to type.
BUT:
- issue working with Identifiers
- issue working with Variables

An identifier is a sequence of characters in the code that identifies a variable, function, or property.

const obj = {
  123: 'digit',
  123name: 'start with digit',
  name123: 'does not start with digit',
  $name: '$ sign',
  name-123: 'hyphen',
  NAME: 'upper case',
  name: 'lower case'
};

obj.123;      // ❌ SyntaxError
obj.123name;  // ❌ SyntaxError
obj.name123;  // ✅ 'does not start with digit'
obj.$name;    // ✅  '$ sign'
obj.name-123;  // ❌ SyntaxError
obj.'name-123';// ❌ SyntaxError
obj.NAME; // ✅ 'upper case'
obj.name; // ✅ 'lower case'

26. Explain the bracket notation in accessing the object properties and its limitations.

const obj = {
  123: 'digit',
  123name: 'start with digit',
  name123: 'does not start with digit',
  $name: '$ sign',
  name-123: 'hyphen',
  NAME: 'upper case',
  name: 'lower case'
};

27. Explain object destructuring in JS and its limitations.

const hero = {
  name: 'Batman'
};

// Object destructuring:
const { name } = hero;
name; // => 'Batman'

const { name } = hero is an object destructuring. The destructuring defines a variable name with the value of property name.

When you get used to object destructuring, you will find that its syntax is a great way to extract the properties into variables.

Choose the object destructuring when you’d like to create a variable having the property value.

Note that you can extract as many properties as you’d like:

const { identifier1, identifier2, .., identifierN } = expression;

Alias variable

If you’d like to access the property, but create a variable name different than the property name, you could use aliasing.

const { identifier: aliasIdentifier } = expression;

identifier is the name of the property to access, aliasIdentifier is the variable name, and expression should evaluate to an object. After the destructuring, the variable aliasIdentifier contains the property value.

const hero = {
  name: 'Batman'
};

// Object destructuring:
const { name: heroName } = hero;
heroName; // => 'Batman'
const { name: heroName } = hero is an object destructuring. The destucturing defines a new variable heroName (instead of name as in previous example), and assigns to heroName the value hero.name.

Dynamic property name

What makes the object destructuring even more useful is that you could extract to variables properties with the dynamic value:

const { [expression]: identifier } = expression;

The first expression should evaluate to a property name, and the identifier should indicate the variable name created after the destructuring. The second expression should evaluate to the object you’d like to destructure.

Here’s an example:

const property = 'name';
const hero = {
  name: 'Batman'
};

// Object destructuring:
const { [property]: name } = hero;
name; // => 'Batman'
const { [property]: name } = hero is an object destructuring that dynamically, at runtime, determines what property to extract.

When the property doesn’t exist
If the accessed property doesn’t exist, all 3 accessor syntaxes evalute to idefined:

const hero = {
  characterName: 'Batman'
};

hero.name;    // => undefined
hero['name']; // => undefined
const { name } = hero;
name;         // => undefined

The property name doesn’t exist in the object hero. Thus the dot property accessor hero.name, square brackets property accessor hero['name'] and the variable name after destructuring evaluate to undefined.

28. What are JS object methods?

const person = {
  firstName: "John",
  lastName: "Doe",
  id: 5566,
  fullName : function() {
    return this.firstName + " " + this.lastName;
  }
};

// Display data from the object:
document.getElementById("demo").innerHTML = person.fullName();

JavaScript methods are actions that can be performed on objects. A JavaScript method is a property containing a function definition.
Methods are functions stored as object properties.

29. How to access object methods in JS?

const handbag = {
    name: "Anna Karenina",
    volume: 20,
    color: "red",
    pocketNum: 3,
    strapLength: {
        left: 24,
        right: 24,
    },
    lidOpen: false,
    toggleLid: function (lidStatus) {
        this.lidOpen = lidStatus;
    },
    newStrapLength: function (lengthLeft, lengthRight) {
        this.strapLength.left = lengthLeft;
        this.strapLength.right = lengthRight;
    },
};

// how methods work
console.log("The handbag object: ", handbag);
console.log("The pocketNum value: ", handbag.pocketNum);

console.log("Left before: ", handbag.strapLength.left);

handbag.newStrapLength(23 , 34);
console.log("Left after: ", handbag.strapLength.left);

30. What are the classes in JS? How to use a class?

ES6 introduced JS Classes. JS classes are templates for JS objects. 

class Car {
  constructor(name, year) {
    this.name = name;
    this.year = year;
  }
}

Always add a method named constructor()

A JavaScript class is not an object. It is a template for JavaScript objects.

How to use a class:

When you have a class, you can use the class to create objects:

Example
let myCar1 = new Car("Ford", 2014);
let myCar2 = new Car("Audi", 2019);

The example above uses the Car class to create two Car objects.

The constructor method is called automatically when a new object is created.

31. What is the constructor method?

The constructor method is a special method:

- It has to have the exact name "constructor"
- It is executed automatically when a new object is created
- It is used to initialize object properties
- If you do not define a constructor method, JavaScript will add an empty constructor method.

32. What is a class method in JS?

Class methods are created with the same syntax as object methods. Use the keyword class to create a class.

Always add a constructor() method. Then add any number of methods.

class ClassName {
  constructor() { ... }
  method_1() { ... }
  method_2() { ... }
  method_3() { ... }
}

Create a Class method named "age", that returns the Car age:

class Car {
  constructor(name, year) {
    this.name = name;
    this.year = year;
  }
  age() {
    let date = new Date();
    return date.getFullYear() - this.year;
  }
}

let myCar = new Car("Ford", 2014);
document.getElementById("demo").innerHTML =
"My car is " + myCar.age() + " years old.";

33. What are the global objects in JS?

The global object in JavaScript is an always defined object that provides variables and functions, and is available anywhere. In a web browser, the global object is the window object, while it is named global in Node. js. The global object can be accessed using the this operator in the global scope.

In addition to the objects you build yourself, either directly or through a class or a constructor, the browser has a long list of default objects you can use for a variety of different purposes. A full list of all of these global objects it's available and extensively documented in the MDN Web Docs. These global objects work exactly like the object we've seen so far except, we don't need to define them, they're just available through the browser, and for the most part we interact with them through their methods. --> STANDARD BUILT-IN OBJECTS.

34. Compare template literals with traditional strings, and explain which one are better to use.

Traditional strings

// ES5 String 
var string = "Hello Alexa";
// ES5 string concatenation
const dog = 'Fluffy';
console log('my dog' + dog + ', is a great pet!)

We use + --> it's cumbersome
Strings are immutable, they can't be altered and whe attempting to add one string to the other, a new one is created. This applies to all of the ways of concatenating strings.

Template Literals
Introduced in ES6

const dog = 'Fluffy;
console.log(`mY DOG, ${dog}, is a great pet!`)

It looks clean and straightforward.

If you ever need to put a back-tick into the string, you need to escape it: to do this, put a backslash before the backtick.

console.log(`Back-tick: ``); // Back-tick: `

A noteworthy aspect of using template literals are multi-line strings. If you press enter in the middle of a template literal, you insert a newline character.

const pets = `Dog: Fluffy
Cat: Garfield`;
 
console.log(pets);
// Dog: Fluffy
// Cat: Garfield

To achieve the same output without template strings, you need to insert newline characters manually:

const pets = 'Dog: Fluffy\nCat: Garfield';
 
console.log(pets);
// Dog: Fluffy
// Cat: Garfield

Hitting enter in a regular string causes Uncaught SyntaxError: Invalid or unexpected token and to prevent it, you need to escape newlines.

const pets = 'Dog: Fluffy\
Cat: Garfield';
This does not insert newline characters though and you still need to add it manually.

35. What is DOM and what is its role?

The Document Object Model (DOM) is an application programming interface (API) for valid HTML and well-formed XML documents. It defines the logical structure of documents and the way a document is accessed and manipulated. ... The DOM is designed to be used with any programming language.

The DOM is known as Document object model and it allows the accessing of the documents like HTML and XML. - It allows a platform to be language neutral and provide an interface that allows the dynamic usage of the scripts and programs to access the content.

36. What are the DOM methods in JS?

The HTML DOM can be accessed with JavaScript (and with other programming languages).

In the DOM, all HTML elements are defined as objects. The programming interface is the properties and methods of each object. A property is a value that you can get or set (like changing the content of an HTML element).
A method is an action you can do (like add or deleting an HTML element).

<html>
<body>
<p id="demo"></p>
<script>
document.getElementById("demo").innerHTML = "Hello World!";
</script>
</body>
</html>

In the example above, getElementById is a method, while innerHTML is a property.

37. What is the most common way to access an HTML element?

- getElementById method
- innerHTML property

The easiest way to get the content of an element is by using the innerHTML property.
The innerHTML property is useful for getting or replacing the content of HTML elements.
The innerHTML property can be used to get or change any HTML element, including <html> and <body>.

38. How you can use the document object to access and manipulate HTML elements? Write the examples.

Finding HTML Elements:
document.getElementById(id) 
document.getElementsByTagName(name) 
document.getElementsByClassName(name) 

Changing HTML Elements:
element.innerHTML 
element.attribute 
element.style.property 
element.setAttribute(attribute, value) -	

Adding and Deleting Elements:

document.createElement(element)
document.removeChild(element)	
document.appendChild(element)	
document.replaceChild(new, old)
document.write(text)	

Adding Events Handlers:

document.getElementById(id).onclick = function()

39. What are the DOM elements JS?

Often, with JavaScript, you want to manipulate HTML elements. To do so, you have to find the elements first. There are several ways to do this:

- Finding HTML elements by id
- Finding HTML elements by tag name
- Finding HTML elements by class name
- Finding HTML elements by CSS selectors
- Finding HTML elements by HTML object collections

const x = document.getElementsByClassName("intro");
const x = document.querySelectorAll("p.intro");
const element = document.getElementsByTagName("p");
const element = document.getElementById("intro");
const x = document.forms["frm1"];
let text = "";
for (let i = 0; i < x.length; i++) {
  text += x.elements[i].value + "<br>";
}
document.getElementById("demo").innerHTML = text;

40. What is HTML DOM?

The HTML DOM allows JavaScript to change the content of HTML elements.
The easiest way to modify the content of an HTML element is by using the innerHTML property.

To change the content of an HTML element, use this syntax:
document.getElementById(id).innerHTML = new HTML

document.write(Date()); --> can be used to write directly to the HTML output stream.

41. What is variable in JS?

Variable is a container with some piece of data. 

42. What is var in JS?

VAR is a reserved keyword to declare a variable. A variable must have a unique name. You can assign a value to a variable using equal to = operator when you declare it or before using it. 

var one = 1;
var three;
var two = 'two';

43. What is the scope in JS?

The scope is an important concept that manages the availability of variables. The scope is at the base closures, defines the idea of global and local variables.

const message = 'Hello';
console.log(message); // 'Hello'

You could easily log this variable in the next line after the declaration. No questions here.

if (true) {
  const message = 'Hello';
}
console.log(message); // ReferenceError: message is not defined

This time, when trying to log the variable, JavaScript throws ReferenceError: message is not defined.

The if code block creates a scope for message variable. And message variable can be accessed only within this scope. At a higher level, the accessibility of variables is limited by the scope where they’re created. You are free to access the variable defined within its scope. But outside of its scope, the variable is inaccessible.

The scope is a policy that manages the accessibility of variables.

44. What is the block scope?

A code block in JavaScript defines a scope for variables declared using let and const:

if (true) {
  // "if" block scope
  const message = 'Hello';
  console.log(message); // 'Hello'
}
console.log(message); // throws ReferenceError

The first console.log(message) correctly logs the variable because message is accessed from the scope where it is defined.

But the second console.log(message) throws a reference error because message variable is accessed outside of its scope: the variable doesn’t exist here.

45. What is the code block of if, for, while in JS scope? 

In the following example for loop defines a scope:

for (const color of ['green', 'red', 'blue']) {
  // "for" block scope
  const message = 'Hi';
  console.log(color);   // 'green', 'red', 'blue'
  console.log(message); // 'Hi', 'Hi', 'Hi'
}
console.log(color);   // throws ReferenceError
console.log(message); // throws ReferenceError
color and message variables exist within the scope of while code block.

Same way the code block of while statement creates a scope for its variables:

while (/* condition */) {
  // "while" block scope
  const message = 'Hi';
  console.log(message); // 'Hi'
}
console.log(message); // => throws ReferenceError
message is defined within while() body, consequently message is accessible only within while() body.

In JavaScript you can define standalone code blocks. The standalone code blocks also delimit a scope:

{
  // block scope
  const message = 'Hello';
  console.log(message); // 'Hello'
}
console.log(message); // throws ReferenceError

46. What is automated image optimization?

Use imagemin --> npm package
npm i imagemin
Squoosh CLI
Sharp

47. How do you target image sizes?

SRCSET

- always provide an image for the smallest screen at 320px
- make your widest possible image 1920px
- control the displayed width for individual images using sizes attribute
- find natural breakpoints and make image sizes to match
- try to limit yourself to 4 or 5 sizes

48. Why is VAR not a block scoped?

The code block creates a scope for variables declared using const and let, but it does not create a scope for the variables declared with VAR. 

if (true) {
  // if block scope
  var count = 0;
  console.log(count); // 0
}
console.log(count); // 0

49. What is a function scope? 

A function in JS define a scope for variables declared using var, let, and const. 

Let's declare a var variable within a function body:

function run() {
  // run function scope
  var message = "Run, Forrest, Run!";
  console.log(message); 
}

50. What is a module scope?

ES2015 module also creates a scope for variables, functions, classes. 

The module circle defines a constant pi:

const pi = 3.14159;
console.log(pi);

pi variable is declared within the scope of circle module. Also, the variable pi is not exported from the module.

51. Can scopes can be nested?

The scope can be nested. 

The function run() creates a scope, and inside an if condition code block creates another scope:

function run() {
 const message = 'Run, Forrest, Run';

if (true) {
  const friend = 'Bubba';
  console.log(message);
}

console.log(friend);
}
run();

If code block scope is nested inside the run() function scope. Scopes of any type - code block, function, module can be nested. The scope contained within another scope is named inner scope. If code block scope is an inner scope of run() function scope. 
The scope that wraps another scope is named outer scope. In the example, run() function scope is an outer scope to if code block scope.

The inner scope can access the variables of its outer scope.

message variable, which is a part of the run() function scope(outer scope), is accessible inside if code block scope(inner scope).

52. What is the global scope?

The global scope is the outermost scope. It is accessible from any inner, local scope. 

In a browser environment, the topmost scope of JS file loaded using <script> tag is a global scope:

<script src="myScript.js"></script>

// global scope
let counter = 1;

A varaible declared inside the global scope is named global variable. Global variables are accessible from any scope. Counter is a global variable, it can be accessed from any place of the webpage's JS. 

The global scope is a mechanism that lets the host of JavaScript (browser, Node) supply applications with host-specific functions as global variables.

window and document, for example, are global variables supplied by the browser. In a Node environment, you can access process object as a global variable.

The global scope is a mechanism that lets the host of JavaScript (browser, Node) supply applications with host-specific functions as global variables.

window and document, for example, are global variables supplied by the browser. In a Node environment, you can access process object as a global variable.

The global scope is a mechanism that lets the host of JavaScript (browser, Node) supply applications with host-specific functions as global variables.

window and document, for example, are global variables supplied by the browser. In a Node environment, you can access process object as a global variable.

The global scope is a mechanism that lets the host of JavaScript (browser, Node) supply applications with host-specific functions as global variables.

window and document, for example, are global variables supplied by the browser. In a Node environment, you can access process object as a global variable.

The global scope is a mechanism that lets the host of JavaScript (browser, Node) supply applications with host-specific functions as global variables.

window and document, for example, are global variables supplied by the browser. In a Node environment, you can access process object as a global variable.

53. What is lexical scope?

Let’s define 2 functions, having the function innerFunc() is nested inside outerFunc().

function outerFunc() {
  // the outer scope
  let outerVar = 'I am from outside!';

  function innerFunc() {
    // the inner scope
    console.log(outerVar); // 'I am from outside!'
  }

  return innerFunc;
}

const inner = outerFunc();
inner();
Look at the last line of the snippet inner(): the innerFunc() invokation happens outside of outerFunc() scope. Still, how does JavaScript understand that outerVar inside innerFunc() corresponds to the variable outerVar of outerFunc()?

The answer is due to lexical scoping.

JavaScript implements a scoping mechanism named lexical scoping (or static scoping). Lexical scoping means that the accessibility of variables is determined statically by the position of the variables within the nested function scopes: the inner function scope can access variables from the outer function scope.

The lexical scope consists of outer scopes determined statically.

In the example, the lexical scope of innerFunc() consists of the scope of outerFunc().

Moreover, the innerFunc() is a closure because it captures the variable outerVar from the lexical scope.

53. What is variable isolation?

An immediate property of scope arises: the scope isolates the variables. And what’s good different scopes can have variables with the same name.

You can reuse common variables names (count, index, current, value, etc) in different scopes without collisions.

foo() and bar() function scopes have their own, but same named, variables count:

function foo() {
  // "foo" function scope
  let count = 0;
  console.log(count); // 0
}

function bar() {
  // "bar" function scope
  let count = 1;
  console.log(count); // 1
}

foo();
bar();

54. What are the general conclusions about the scope in JS?

The scope is a policy that manages the availability of variables. A variable defined inside a scope is accessible only within that scope, but inaccessible outside. In JS, scope are created by code blocks, functions, modules.  

While const and let variables are scoped by code blocks, functions or modules, var variables are scoped only by functions or modules.

const, let --> code blocks, functions, modules
var --> functions, modules

Scope can be nested. Inside an inner scope you can access the variables of an outer scope.

The lexical scope consists of the outer function scopes determined statically. Any function, no matter the place where being executed, can access the variables of its lexical scope (the concept of closure).

55. Describe how does DOM form work in JS?

HTML form validation can be done by JavaScript.

If a form field (fname) is empty, this function alerts a message, and returns false, to prevent the form from being submitted:

function validateForm() {
  let x = document.forms["myForm"]["fname"].value;
  if (x == "") {
    alert("Name must be filled out");
    return false;
  }
}

The function can be called when the form is submitted:

<form name="myForm" action="/action_page.php" onsubmit="return validateForm()" method="post">
Name: <input type="text" name="fname">
<input type="submit" value="Submit">
</form>

HTML form validation can be performed automatically by the browser:

If a form field (fname) is empty, the required attribute prevents this form from being submitted:

<form action="/action_page.php" method="post">
  <input type="text" name="fname" required>
  <input type="submit" value="Submit"
</form>

Automatic HTML form validation does not work in Internet Explorer 9 or earlier.

56. What is data validation in JS?

Data validation is the process of ensuring that user input is clean, correct, and useful.

Typical validation tasks are:

- has the user filled in all required fields?
- has the user entered a valid date?
- has the user entered text in a numeric field?

Most often, the purpose of data validation is to ensure correct user input.

Validation can be defined by many different methods, and deployed in many different ways.

Server side validation is performed by a web server, after input has been sent to the server.

Client side validation is performed by a web browser, before input is sent to a web server.

57. What is the HTML Constraint Validation?

HTML5 introduced a new HTML validation concept called constraint validation.

HTML constraint validation is based on:

- Constraint validation HTML Input Attributes
- Constraint validation CSS Pseudo Selectors
- Constraint validation DOM Properties and Methods

Constraint Validation HTML Input Attributes:
- disbaled, max, min, pattern, required, type

Constraint Validation CSS Pseudo Selectors:
- :disabled, :invalid, :optional, :required, :valid

58. Describe how does HTML DOM allow JS to change the style of HTML elements>

The HTML DOM allows JavaScript to change the style of HTML elements.

document.getElementById(id).style.property = new style

<html>
<body>
<p id="p2">Hello World!</p>
<script>
document.getElementById("p2").style.color = "blue";
</script>
</body>
</html>

59. Does HTML DOM allow you to execute code when an event occur?

Events are generated by the browser when "things happen" to HTML elements:

- An element is clicked on
- The page has loaded
- Input fields are changed
- You will learn more about events in the next chapter of this tutorial.

This example changes the style of the HTML element with id="id1", when the user clicks a button:

<!DOCTYPE html>
<html>
<body>
<h1 id="id1">My Heading 1</h1>
<button type="button"
onclick="document.getElementById('id1').style.color = 'red'">
Click Me!</button>
</body>
</html>

60. Can we create animations with HTML DOM JS?

To demonstrate how to create HTML animations with JavaScript, we will use a simple web page:

<!DOCTYPE html>
<html>
<body>
<h1>My First JavaScript Animation</h1>
<div id="animation">My animation will go here</div>
</body>
</html>

61. Describe HTML DOM Events.

A JavaScript can be executed when an event occurs, like when a user clicks on an HTML element.

To execute code when a user clicks on an element, add JavaScript code to an HTML event attribute:

onclick=JavaScript

Examples of HTML events:

- When a user clicks the mouse
- When a web page has loaded
- When an image has been loaded
- When the mouse moves over an element
- When an input field is changed
- When an HTML form is submitted
- When a user strokes a key

In this example, the content of the <h1> element is changed when a user clicks on it:

<!DOCTYPE html>
<html>
<body>
<h1 onclick="this.innerHTML = 'Ooops!'">Click on this text!</h1>
</body>
</html>

In this example, a function is called from the event handler:
<!DOCTYPE html>
<html>
<body>
<h1 onclick="changeText(this)">Click on this text!</h1>
<script>
function changeText(id) {
  id.innerHTML = "Ooops!";
}
</script>
</body>
</html>

62. Describe DOM Event Listener. Describe the addEventListener() method.

Add an event listener that fires when a user clicks a button:

document.getElementById("myBtn").addEventListener("click", displayDate);

The addEventListener() method attaches an event handler to the specified element.

The addEventListener() method attaches an event handler to an element without overwriting existing event handlers.

You can add many event handlers to one element.

You can add many event handlers of the same type to one element, i.e two "click" events.

You can add event listeners to any DOM object not only HTML elements. i.e the window object.

The addEventListener() method makes it easier to control how the event reacts to bubbling.

When using the addEventListener() method, the JavaScript is separated from the HTML markup, for better readability and allows you to add event listeners even when you do not control the HTML markup.

You can easily remove an event listener by using the removeEventListener() method.

element.addEventListener(event, function, useCapture);

The first parameter is the type of the event (like "click" or "mousedown" or any other HTML DOM Event.)

The second parameter is the function we want to call when the event occurs.

The third parameter is a boolean value specifying whether to use event bubbling or event capturing. This parameter is optional.

Note that you don't use the "on" prefix for the event; use "click" instead of "onclick".

63. How to add Event Handler to and Element?

Alert "Hello World!" when the user clicks on an element:

element.addEventListener("click", function(){ alert("Hello World!"); });

You can also refer to an external "named" function:

Alert "Hello World!" when the user clicks on an element:

element.addEventListener("click", myFunction);

function myFunction() {
  alert ("Hello World!");
}

64. How to add many event handlers to the same element?

The addEventListener() method allows you to add many events to the same element, without overwriting existing events:

element.addEventListener("click", myFunction);
element.addEventListener("click", mySecondFunction);

You can add events of different types to the same element:

element.addEventListener("mouseover", myFunction);
element.addEventListener("click", mySecondFunction);
element.addEventListener("mouseout", myThirdFunction);

65. How to add event handler to the window object?

The addEventListener() method allows you to add event listeners on any HTML DOM object such as HTML elements, the HTML document, the window object, or other objects that support events, like the xmlHttpRequest object.

Add an event listener that fires when a user resizes the window:

window.addEventListener("resize", function(){
  document.getElementById("demo").innerHTML = sometext;
});

66. How to pass parameters in HTML DOM JS?

When passing parameter values, use an "anonymous function" that calls the specified function with the parameters:

element.addEventListener("click", function(){ myFunction(p1, p2); });

67. What is the difference between Event Bubbling or Event Capturing?

There are two ways of event propagation in the HTML DOM, bubbling and capturing.

Event propagation is a way of defining the element order when an event occurs. If you have a <p> element inside a <div> element, and the user clicks on the <p> element, which element's "click" event should be handled first?

In bubbling the inner most element's event is handled first and then the outer: the <p> element's click event is handled first, then the <div> element's click event.

In capturing the outer most element's event is handled first and then the inner: the <div> element's click event will be handled first, then the <p> element's click event.

With the addEventListener() method you can specify the propagation type by using the "useCapture" parameter:

addEventListener(event, function, useCapture);
The default value is false, which will use the bubbling propagation, when the value is set to true, the event uses the capturing propagation.

document.getElementById("myP").addEventListener("click", myFunction, true);
document.getElementById("myDiv").addEventListener("click", myFunction, true);

68. How does removeEventListener() method work?

The removeEventListener() method removes event handlers that have been attached with the addEventListener() method:

element.removeEventListener("mousemove", myFunction);

69. What is let in JS?

LET --> is now preferred for variable declaration. 

LET IS BLOCK SCOPED:
- A block is a chunk of code bounded by {}. A block lives in curly braces. Anything within curly braces is a block. 

A variable delcared in a block with LET is only avialable for use within that block. 

  let greeting = "say Hi";
   let times = 4;

   if (times > 3) {
        let hello = "say Hello instead";
        console.log(hello);// "say Hello instead"
    }
   console.log(hello) // hello is not defined

We see that using hello outside its block (the curly braces where it was defined) returns an error. This is because let variables are block scoped .

LET CAN BE UPDATED BUT NOT RE-DECLARED:
Just like var,  a variable declared with let can be updated within its scope. Unlike var, a let variable cannot be re-declared within its scope. So while this will work:

   let greeting = "say Hi";
   greeting = "say Hello instead";

this will return an error:
 
   let greeting = "say Hi";
   let greeting = "say Hello instead"; // error: Identifier 'greeting' has already been declared

However, if the same variable is defined in different scopes, there will be no error:

 let greeting = "say Hi";
    if (true) {
        let greeting = "say Hello instead";
        console.log(greeting); // "say Hello instead"
    }
    console.log(greeting); // "say Hi"

Why is there no error? This is because both instances are treated as different variables since they have different scopes.

This fact makes let a better choice than var. When using let, you don't have to bother if you have used a name for a variable before as a variable exists only within its scope.

Also, since a variable cannot be declared more than once within a scope, then the problem discussed earlier that occurs with var does not happen.

HOISTING OF LET
Just like  var, let declarations are hoisted to the top. Unlike var which is initialized as undefined, the let keyword is not initialized. So if you try to use a let variable before declaration, you'll get a Reference Error.

70. What is const in JS?

Variables declared with the const maintain constant values. const declarations share some similarities with let declarations.

CONST DECLARATIONS ARE BLOCK SCOPED
Like let declarations, const declarations can only be accessed within the block they were declared.

CONST CANNOT BE UPDATED OR RE-DECLARED
This means that the value of a variable declared with const remains the same within its scope. It cannot be updated or re-declared. So if we declare a variable with const, we can neither do this:

 const greeting = "say Hi";
    greeting = "say Hello instead";// error: Assignment to constant variable. 

nor this:

 const greeting = "say Hi";
    const greeting = "say Hello instead";// error: Identifier 'greeting' has already been declared

Every const declaration, therefore, must be initialized at the time of declaration.

This behavior is somehow different when it comes to objects declared with const. While a const object cannot be updated, the properties of this objects can be updated. Therefore, if we declare a const object as this:

  const greeting = {
        message: "say Hi",
        times: 4
    }

while we cannot do this:

  greeting = {
        words: "Hello",
        number: "five"
    } // error:  Assignment to constant variable.

we can do this:

  greeting.message = "say Hello instead";

This will update the value of greeting.message without returning errors.

HOISTING OF CONST

Just like let, const declarations are hoisted to the top but are not initialized.

So just in case you missed the differences, here they are:

- var declarations are globally scoped or function scoped while let and const are block scoped.
- var variables can be updated and re-declared within its scope; let variables can be updated but not re-declared; const variables can neither be updated nor re-declared.
- They are all hoisted to the top of their scope. But while var variables are initialized with undefined, let and const variables are not initialized.
- While var and let can be declared without being initialized, const must be initialized during declaration.

71. What is an advantage of using a constructor function to build objects?

It lets you avoid writing redundant code.

72. To create an object literal, you specify an object as the value of _____.

a variable

73. What does it mean when we say JavaScript is an "object-oriented" language?

JavaScript is modeled around objects with properties and methods which can be handled in a modular fashion.

74. What happens to the website and the code when you write code in the browser console?

Code in the browser console impacts the current browser instance only. It exists in the console for as long as the window is open.

75. What is an indicator of someone being a good JavaScript developer?

They follow standards, invest in learning, use formatting and linting tools for consistency, and write accessible code.

76. What is the natural environment for JavaScript?

The browser, server environments, and your computer.

77. What is ECMAScript?

The specification describing how browsers should implement and interpret JavaScript.

78. Where should you develop and test your JavaScript code?

Develop in a code editor, test in as many browsers as you can get your hands on.

79. Why have command line and automation tools become popular in JavaScript development?

They simplify complex processes and introduce features to help developers write better code.

80. When does the browser execute JavaScript?

By default: When the script is encountered. If the script is set to "async", when the script is fully loaded. If the script is set to "defer", when the entire HTML page is rendered.

81. What is the correct markup for adding an external JavaScript file to an HTML document?

<script src="javascript.js" async></script>

While `<script src="javascript.js"></script>` is technically correct, it is recommended to always async or defer your script unless you have a specific reason for the script to cause render blocking.

82. What happens when you defer JavaScript?

The browser loads the JavaScript asynchronously when it is encountered, then waits until all HTML is rendered before executing the script.

83. JavaScript modules are heavily used in frameworks like React and Vue. What is the advantage of using modules?

Modules enable modularization of code where individual functions, components, data objects, and other parts can be separated into individual files.

84. What will be printed to the console as the following script is running?
 
 var sqrt = (function(x) {
  console.log(x*x);
 })(my_number)

 my_number = 5;

ERROR OUTPUT

85. In a switch statement, what happens when several of the switch cases resolve to true?

The switch statement returns the first case that resolves to true, then stops.

86. What is the new value of myArray after this script executes?
 
const myArray = [1, 2, 3, 4]
myArray.forEach( (item, index) => {
    myArray[index] = ++item;
});

[2,3,4,5]

87. What is the difference between the array.forEach() and array.map() methods?

array.forEach() executes a provided callback function once for each item in the array. array.map() creates a new array with the results of executing a provided callback function once for each item in the original array.

88. Anonymous functions are dangerous because they can be triggered by accident.

FALSE

89. What logical operator signifies negation (not)?

!

90. How do you capture a value returned from a function?

The value is returned to where the function was called, effectively replacing the function call.

91. What is the purpose of the return keyword in this function?
 
const myFunction = (data, modifier) => {
   if (data >= 3) {
      return;
   } else {
      console.log(data + modifier);
   }
}

The return keyword stops the function from executing if the conditional statement is true.

92. 
What is meant when we say a function has a callback?

A callback function is a function passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or action.

93. What is logged in the console when the following script executes:
 
const number = 10;
if (number <= 9) {
   console.log("<=9");
} else if ( number >= 10 ){
   console.log(">=10");
}

">=10"

94. Which of the following options is correct syntax for an arrow function?

const myFunction = (data) => {
   console.log(data);
};

94. True or false: An arrow function can be used to define an object method.

FALSE

95. What is logged in the console when this script executes?
 
const myFunction = (data) => {
   return;
   let newData = data + 1;
   return newData;
}

console.log(myFunction(5));

Nothing (undefined)

When the `return` statement is encountered, the function ends. In this example, the `return` statement is the first entry in the function, so nothing else executes.

96. What happens when you assign values to parameters in a function declaration as exemplified below:
 
const myFunction = (data = 5, color = "red") => {}

Default values are created for each parameter. If no value is passed to the function, these values are used.

97. What will the following script print?
 
 function myfunc(x,y) {
  return(x+y);
 }
 console.log(myfunc(2,myfunc(5,-2)));

5

98. Which answer is a valid example of calling the function expression defined below?
 
const myFunction = function(a) {};

myFunction(1);

99. What is the difference between a function expression and a function declaration?

A function declaration defines a function with the specified parameters starting with the function keyword. A function expression expresses a function inside a variable by assigning the function to the variable.

100. An event listener can be appended to the window object?

TRUE

Event listeners are often used to listen for when the document is fully loaded in the browser. For this and other window events, we append an event listener to the window object.

101. What goes in place of a and b in this standard event listener?

element.addEventListener("__a__", "__b__");

a: the event name b: the function to call when the event fires

102. What does 'this' refer to in the following event listener definition?
 
myElement.addEventListener(eventName, function(e) {
    eventFunction(e,this);
});

The element in myElement

103. Why does this return the window object in the following event listener definition?
 
myElement.addEventListener(eventName, () => {
    console.log(this);
});

Arrow functions do not have their own this, so they refer to the closest defined this which is the window object.

104. Can a value be passed through an event listener to its callback function?

Yes, by capturing the value in a new function inside the callback function.

105. When is the resize event triggered?

When the document view is resized.

106. How do you capture the event object in an event listener?

The event object is automatically passed as a parameter to the callback function. Simply name and use the parameter.

107. If you create several event listeners listening to the same event, only the last one in the script will work.

FALSE

108. What is the first troubleshooting step when your JavaScript is not working as expected?

Look for errors in the browser console.

109. What is the keyboard shortcut to comment out one or more highlighted lines of code in the code editor?

On Windows: Ctrl+/ On Mac: Cmd+/

110. Given the code below, how do you access the property named in let propName? ``` let propName = "color";
 
const myObject = { 
 ID = 3,
 color = "pink", 
 propLength = 4, 
 use = false 
}

Bracket notation:
myObject[propName]

111. In the following object, what is the code in the second line called?
 
const myObject = {
    color: "pink"
};

An object property with a property name and a property value.

112. Why is the best-practice to place objects inside constants?

So the object isn't accidentally altered or overwritten.

113. Which of the below object property names are not valid?
 
const myObject = {
    propName = "property",         // line 1
    prop-name = "hyphenated",  // line 2
    3rdProp = "numbered",          // line 3
    $prop = "dollar",                      // line 4
    %prop = "percentage",           // line 5
    prop name = "space"              // line 6
};

Lines 2, 3, 5, and 6

114. How do you access an object in JavaScript?

Call the object by naming its container.

115. Can an object created from a class be given the same name as the class?

No: If the class is a constant, this will cause an error. If the class is not a constant, the new object will overwrite the class.

116. How do you define an object in JavaScript?

Create a variable, give it a name, and assign it an object using curly brackets:
const myObject = {
  // Properties and methods go here.
};

117. What does the this keyword refer to in a class?

this refers to the current object created from the class.

118. Where do you go to find official documentation and code examples for standard built in (global) objects?`

The MDN Web Docs for standard built-in objects

119. How do you create a new object from a class?

Using the new keyword, naming the class, and passing the properties as parameters.

120. What is one advantage to using a class over an object constructor method?

Classes can be extended.

121. What is the established convention for formatting objects?

All properties and methods are listed on their own separate line.

122. What is the difference between a function and a method?

A function is a stand-alone function. A method is a function within an object.

123. Can you use arrow functions to create object methods?

No, object methods must be declared using function expressions or the method definition shorthand.

124. When creating a class, the prototype methods are added inside the constructor method.

FALSE

Class prototype methods are added after the constructor method as discrete named methods.

125. How do you declare a JavaScript expression inside a template literal?

const myString = `Some text and an ${expression}.`;

126. What does the following code output in the console?
 
let number = 5;
let subtracted = 5-1;
console.log("The number before" + number + "is" + subtracted + ".");

The number before5is4.

127. What method(s) would you use to check if an element has a specific ID and if so replace it with a different ID?

the element.hasAttribute() and element.setAttribute() methods.

128. What is the difference in the return from the element.className and element.classList properties?

element.className returns a string containing all classes appended to the element. element.classList returns a DOMTokenList with each class appended to the element.

129. What does the HTML markup of this image element look like after the following script has executed?
 
const newImage = document.createElement("img");
newImage.classList.add("feat-img");
newImage.setAttribute("src", "logo.svg");
newImage.setAttribute("alt", "The company logo");
newImage.style.cssText = "display: block";

<img class="feat-img" src="logo.svg" alt="The company logo" style="display: block;">

130. What is the value of const target after this code has executed? 
 
const target = document.querySelectorAll("a");

A node list containing each element object matching the query.

131. What is the value of const target after this code has executed (assuming there are elements in the DOM with the class "note")? 
 
const target = document.getElementsByClassName(".note");

An empty array-like HTMLCollection object.

132. The querySelector() and querySelectorAll() methods use what kind of selectors as their parameter?

A CSS selector string.

133. What happens if you run this code:
 
const target = document.querySelector(".first-paragraph");
target.style.font-family = "sans-serif";

"Uncaught SyntaxError: Invalid left-hand side in assignment"

JavaScript does not allow for hyphens in property names. When targeting CSS properties, use camelCase, so the "font-family" property becomes "fontFamily".

134. What does the element.classList.toggle() method do?

Adds the specified class if it is not appended to the element, removes the specified class if it is appended to the element.

135. Where in the HTML document does the new element appear when you use the document.createElement() method?

Nowhere: The element is created, but has not been added to the DOM.