1. What are classes in OOP?

In a nutshell, classes are essentially user defined data types. Classes are where we create a blueprint for the structure of methods and attributes. Individual objects are instantiated, or created from this blueprint.

Classes contain fields for attributes, and methods for behaviors. In our Dog class example, attributes include name & birthday, while methods include bark() and updateAttendance().

class Dog {
    constructor(name, birthday) {
        this.name = name;
        this.birthday = birthday;
    }

    //Declare private variables
    _attendance = 0;

    getAge() {
        //Getter
        return this.calcAge();
    }

    calcAge() {
        //calculate age using today's date and birthday
        return Date.now() - this.birthday;
    }
    
    bark() {
        return console.log("Woof!");
    }

    updateAttendance() {
        //add a day to the dog's attendance days at the petsitters
        this._attendance++;
    }
}

Remember the class is a template for modeling a dog, and an object is instantiated from the class representing an individual real world thing.

2. What is the Observer design pattern?

If you've ever used the MVC pattern, you've already used the observer design pattern. The Model part is like a subject and the View part is like an observer of that subject. Your subject holds all of the data and the state of that data. Then you have observers, like different components, that will get that data from the subject when the data has been updated.

The goal of the observer design pattern is to create this one-to-many relationship between the subject and all of the observers waiting for data so they can be updated. So anytime the state of the subject changes, all of the observers will be notified and updated instantly.

Some examples of when you would use this pattern include: sending user notifications, updating, filters, and handling subscribers.

Say you have a single page application that has three feature dropdown lists that are dependent on the selection of a category from a higher level dropdown. This is common on many shopping sites, like Home Depot. You have a bunch of filters on the page that are dependent on the value of a top-level filter.

The code for the top-level dropdown might look something like this:

class CategoryDropdown {
  constructor() {
    this.categories = ['appliances', 'doors', 'tools']
    this.subscriber = []
  }
  
  // pretend there's some fancy code here
  
  subscribe(observer) {
    this.subscriber.push(observer)
  }
  
  onChange(selectedCategory) {
    this.subscriber.forEach(observer => observer.update(selectedCategory))
  }
}

This CategoryDropdown file is a simple class with a constructor that initializes the category options we have available for in the dropdown. This is the file you would handle retrieving a list from the back-end or any kind of sorting you want to do before the user sees the options.

The subscribe method is how each filter created with this class will receive updates about the state of the observer.

The onChange method is how we send out notification to all of the subscribers that a state change has happened in the observer they're watching. We just loop through all of the subscribers and call their update method with the selectedCategory.

The code for the other filters might look something like this:
class FilterDropdown {
  constructor(filterType) {
    this.filterType = filterType
    this.items = []
  }
  
  // more fancy code here; maybe make that API call to get items list based on filterType
  
  update(category) {
    fetch('https://example.com')
      .then(res => this.items(res))
  }
}

This FilterDropdown file is another simple class that represents all of the potential dropdowns we might use on a page. When a new instance of this class is created, it needs to be passed a filterType. This could be used to make specific API calls to get the list of items.

The update method is an implementation of what you can do with the new category once it has been sent from the observer.

Now we'll take a look at what it means to use these files with the observer pattern:

const CategoryDropdown = require('./CategoryDropdown')
const FilterDropdown = require('./FilterDropdown')

const categoryDropdown = new CategoryDropdown() 

const colorsDropdown = new FilterDropdown('colors')
const priceDropdown = new FilterDropdown('price')
const brandDropdown = new FilterDropdown('brand')

categoryDropdown.subscribe(colorsDropdown)
categoryDropdown.subscribe(priceDropdown)
categoryDropdown.subscribe(brandDropdown)

What this file shows us is that we have 3 drop-downs that are subscribers to the category drop-down observable. Then we subscribe each of those drop-downs to the observer. Whenever the category of the observer is updated, it will send out the value to every subscriber which will update the individual drop-down lists instantly.

3. What is the Decorator design pattern?

Using the decorator design pattern is fairly simple. You can have a base class with methods and properties that are present when you make a new object with the class. Now say you have some instances of the class that need methods or properties that didn't come from the base class.

You can add those extra methods and properties to the base class, but that could mess up your other instances. You could even make sub-classes to hold specific methods and properties you need that you can't put in your base class.

Either of those approaches will solve your problem, but they are clunky and inefficient. That's where the decorator pattern steps in. Instead of making your code base ugly just to add a few things to an object instance, you can tack on those specific things directly to the instance.

So if you need to add a new property that holds the price for an object, you can use the decorator pattern to add it directly to that particular object instance and it won't affect any other instances of that class object.

Have you ever ordered food online? Then you've probably encountered the decorator pattern. If you're getting a sandwich and you want to add special toppings, the website isn't adding those toppings to every instance of sandwich current users are trying to order.

Here's an example of a customer class:

class Customer {
  constructor(balance=20) {
    this.balance = balance
    this.foodItems = []
  }
  
  buy(food) {
    if (food.price) < this.balance {
      console.log('you should get it')
      this.balance -= food.price
      this.foodItems.push(food)
    }
    else {
      console.log('maybe you should get something else')
    }
  }
}

module.exports = Customer

And here's an example of a sandwich class:

class Sandwich {
  constructor(type, price) {
    this.type = type
    this.price = price
  }
  
  order() {
    console.log(`You ordered a ${this.type} sandwich for $ ${this.price}.`)
  }
}

class DeluxeSandwich {
  constructor(baseSandwich) {
    this.type = `Deluxe ${baseSandwich.type}`
    this.price = baseSandwich.price + 1.75
  }
}

class ExquisiteSandwich {
  constructor(baseSandwich) {
    this.type = `Exquisite ${baseSandwich.type}`
    this.price = baseSandwich.price + 10.75
  }
  
  order() {
    console.log(`You ordered an ${this.type} sandwich. It's got everything you need to be happy for days.`)
  }
}

module.exports = { Sandwich, DeluxeSandwich, ExquisiteSandwich }

This sandwich class is where the decorator pattern is used. We have a Sandwich base class that sets the rules for what happens when a regular sandwich is ordered. Customers might want to upgrade sandwiches and that just means an ingredient and price change.

You just wanted to add the functionality to increase the price and update the type of sandwich for the DeluxeSandwich without changing how it's ordered. Although you might need a different order method for an ExquisiteSandwich because there is a drastic change in the quality of ingredients.

The decorator pattern lets you dynamically change the base class without affecting it or any other classes. You don't have to worry about implementing functions you don't know, like with interfaces, and you don't have to include properties you won't use in every class.

Now if we'll go over an example where this class is instantiated as if a customer was placing a sandwich order.

const { Sandwich, DeluxeSandwich, ExquisiteSandwich } = require('./Sandwich')
const Customer = require('./Customer')

const cust1 = new Customer(57)

const turkeySandwich = new Sandwich('Turkey', 6.49)
const bltSandwich = new Sandwich('BLT', 7.55)

const deluxeBltSandwich = new DeluxeSandwich(bltSandwich)
const exquisiteTurkeySandwich = new ExquisiteSandwich(turkeySandwich)

cust1.buy(turkeySandwich)
cust1.buy(bltSandwich)

4. What are 23 design patterns?

- CREATIONAL: Factory Method, Abstract Factory, Builder, Prototype, Singleton.
- STRUCTURAL: Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy.
- BEHAVIORAL: Interpreter Template Method, Chain of Responsability, Command, Iterator, Mediator, Memento, Observer, State, Strategy, Visitor.

5. What are the easiest design pattern to study?

Adapter, Decorator, Composite, Observer, Template Method, Factory Method, Abstract Factory, Strategy.

6. How to structure OOP programs?

Imagine running a dog sitting camp, with hundreds of pets, and you have to keep track of the names, ages, and days attended for each pet. How would you design simple, reusable software to model the dogs?

With hundreds of dogs, it would be inefficient to write unique code for each dog. Below we see what that might look like with objects rufus and fluffy.

//Object of one individual dog
var rufus = {
    name: "Rufus",
    birthday: "2/1/2017",
    age: function() {
        return Date.now() - this.birthday;
    },
    attendance: 0
}

//Object of second individual dog
var fluffy = {
    name: "Fluffy",
    birthday: "1/12/2019",
    age: function() {
        return Date.now() - this.birthday;
    },
    attendance: 0
}

As you can see above, there is a lot of duplicated code between both objects. The age() function appears in each object. Since we want the same information for each dog, we can use objects and classes instead.

Grouping related information together to form a class structure makes the code shorter and easier to maintain.

In the dogsitting example, here’s how a programmer could think about organizing an OOP:

Create a parent class for all dogs as a blueprint of information and behaviors (methods) that all dogs will have, regardless of type.

Create child classes to represent different subcategories of dog under the generic parent blueprint.

Add unique attributes and behaviors to the child classes to represent differences

Create objects from the child class that represent dogs within that subgroup

The diagram below represents how to design an OOP program: grouping the related data and behaviors together to form a simple template then creating subgroups for specialized data and behavior.

The Dog class is a generic template, containing only the structure about data and behaviors common to all dogs.

We then create two child classes of Dog, HerdingDog and TrackingDog. These have the inherited behaviors of Dog (bark()) but also behavior unique to dogs of that subtype.

Finally, we create objects of the HerdingDog type to represent the individual dogs Fluffy and Maisel.

We can also create objects like Rufus that fit under the broad class of Dog but do not fit under either HerdingDog or TrackingDog.

7. What are the building blocks of OOP?

- classes
- objects
- methods
- attributes

8. What is OOP?

Object Oriented programming (OOP) is a programming paradigm that relies on the concept of classes and objects. It is used to structure a software program into simple, reusable pieces of code blueprints (usually called classes), which are used to create individual instances of objects. There are many object-oriented programming languages including JavaScript, C++, Java, and Python.

9. What are the benefits of OOP?

- OOP models complex things as reproducible, simple structures
- Reusable, OOP objects can be used across programs
- Allows for class-specific behavior through polymorphism
- Easier to debug, classes often contain all applicable information to them
- Secure, protects information through encapsulation

10. What are the objects in OOP?

Objects are instances of classes created with specific data, for example in the code snippet below Rufus is an instance of the Dog class.

class Dog {
    constructor(name, birthday) {
        this.name = name;
        this.birthday = birthday;
    }

    //Declare private variables
    _attendance = 0;

    getAge() {
        //Getter
        return this.calcAge();
    }

    calcAge() {
        //calculate age using today's date and birthday
        return Date.now() - this.birthday;
    }
    
    bark() {
        return console.log("Woof!");
    }

    updateAttendance() {
        //add a day to the dog's attendance days at the petsitters
        this._attendance++;
    }
}

//instantiate a new object of the Dog class, and individual dog named Rufus
const rufus = new Dog("Rufus", "2/1/2017");

When the new class Dog is called:

A new object is created named rufus
The constructor runs name & birthday arguments, and assigns values
Programming vocabulary:

In JavaScript objects are a type of variable. This may cause confusion, because objects can also be declared without a class template in JavaScript, as shown at the beginning.

Objects have states and behaviors. State is defined by data: things like names, birthday, and other information you’d want to store about a dog. Behaviors are methods, the object can undertake.

11. What are the attributes of OOP?

Attributes are the information that is stored. Attributes are defined in the Class template. When objects are instantiated individual objects contain data stored in the Attributes field.

The state of an object is defined by the data in the object’s attributes fields. For example, a puppy and a dog might be treated differently at pet camp. The birthday could define the state of an object, and allow the software to handle dogs of different ages differently.

12. What are the methods of OOP?

Methods represent behaviors. Methods perform actions; methods might return information about an object, or update an object’s data. The method’s code is defined in the class definition.

When individual objects are instantiated, these objects can call the methods defined in the class. In the code snippet below, the bark method is defined in Dog class, and the bark() method is called on the Rufus object.

13. What are the 4 princiles of OOP?

The four pillars of object oriented programming are:

- Inheritance: child classes inherit data and behaviors from parent class
- Encapsulation: containing information in an object, exposing only selected information
- Abstraction: only exposing high level public methods for accessing an object
- Polymorphism: many methods can do the same task

14. What is the inheritance in OOP?

Inheritance allows classes to inherit features of other classes. Put another way, parent classes extend attributes and behaviors to child classes. Inheritance supports reusability.

If basic attributes and behaviors are defined in a parent class, child classes can be created extending the functionality of the parent class, and adding additional attributes and behaviors.

For example, herding dogs have the unique ability to herd animals. In other words, all herding dogs are dogs, but not all dogs are herding dogs. We represent this difference by creating a child class HerdingDog from the parent class Dog, and then add the unique herd() behavior.

The benefits of inheritance are programs can create a generic parent class, and then create more specific child classes as needed. This simplifies overall programming, because instead of recreating the structure of the Dog class multiple times, child classes automatically gain access to functionalities within their parent class.

In the following code snippet, child class HerdingDog inherits the method bark from the parent class Dog, and the child class adds an additional method, herd().

//Parent class Dog
class Dog{
    //Declare protected (private) fields
    _attendance = 0;

    constructor(namee, birthday) {
        this.name = name;
        this.birthday = birthday;
    }

    getAge() {
        //Getter
        return this.calcAge();
    }

    calcAge() {
        //calculate age using today's date and birthday
        return this.calcAge();
    }

    bark() {
        return console.log("Woof!");
    }

    updateAttendance() {
        //add a day to the dog's attendance days at the petsitters
        this._attendance++;
    }
}

//Child class HerdingDog, inherits from parent Dog
class HerdingDog extends Dog {
    constructor(name, birthday) {
        super(name);
        super(birthday);
    }

    herd() {
        //additional method for HerdingDog child class
        return console.log("Stay together!")
    }
}

Notice that the HerdingDog class does not have a copy of the bark() method, it inherits the bark() method defined in the parent Dog class.

When the code calls fluffy.bark() method, the bark() method walks up the chain of child to parent classes, to find where the bark method is defined.

//Parent class Dog
class Dog{
    //Declare protected (private) fields
    _attendance = 0;

    constructor(namee, birthday) {
        this.name = name;
        this.birthday = birthday;
    }

    getAge() {
        //Getter
        return this.calcAge();
    }

    calcAge() {
        //calculate age using today's date and birthday
        return this.calcAge();
    }

    bark() {
        return console.log("Woof!");
    }

    updateAttendance() {
        //add a day to the dog's attendance days at the petsitters
        this._attendance++;
    }
}

//Child class HerdingDog, inherits from parent Dog
class HerdingDog extends Dog {
    constructor(name, birthday) {
        super(name);
        super(birthday);
    }

    herd() {
        //additional method for HerdingDog child class
        return console.log("Stay together!")
    }
}

//instantiate a new HerdingDog object
const fluffy = new HerdingDog("Fluffy", "1/12/2019");
fluffy.bark();

Note: Parent class is also known as super class, or base class. Child class can also be called derived class, or extended class.

In JavaScript, inheritance is also known as prototyping. A prototype object acts as a template for another object to inherit properties and behaviors from. There can be multiple prototype object templates, creating a prototype chain.

This is the same concept as the parent/child inheritance. Inheritance is from parent to child. In our example all three dogs can bark, but only Maisel and Fluffy can herd.

The herd() method is defined in the child HerdingDog class, so the two objects, Maisel and Fluffy, instantiated from the HerdingDog class have access to the herd() method.

Rufus is an object instantiated from the parent class Dog, so Rufus only has access to the bark() method.

15. What is encapsulation in OOP?
﻿
Encapsulation means containing all important information inside an object, and only exposing selected information to the outside world. Attributes and behaviors are defined by code inside the class template.
﻿
Then, when an object is instantiated from the class, the data and methods are encapsulated in that object. Encapsulation hides the internal software code implementation inside a class, and hides internal data of inside objects.
﻿
Encapsulation requires defining some fields as private and some as public.
﻿
Private/ Internal interface: methods and properties, accessible from other methods of the same class.
Public / External Interface: methods and properties, accessible also from outside the class.
Let’s use a car as a metaphor for encapsulation. The information the car shares with the outside world, using blinkers to indicate turns, are public interfaces. In contrast, the engine is hidden under the hood.
﻿
It’s a private, internal interface. When you’re driving a car down the road, other drivers require information to make decisions, like whether you’re turning left or right. However, exposing internal, private data like the engine temperature, would just confuse other drivers.
﻿
Encapsulation adds security. Attributes and methods can be set to private, so they can’t be accessed outside the class. To get information about data in an object, public methods & properties are used to access or update data.
﻿
This adds a layer of security, where the developer chooses what data can be seen on an object by exposing that data through public methods in the class definition.
﻿
Within classes, most programming languages have public, protected, and private sections. Public is the limited selection of methods available to the outside world, or other classes within the program. Protected is only accessible to child classes.
﻿
Private code can only be accessed from within that class. To go back to our dog/owner example, encapsulation is ideal so owners can’t access private information about other people’s dogs.
﻿
Note: JavaScript has private and protected properties and methods. Protected Fields are prefixed with a _ ; private fields are prefixed with a #. Protected fields are inherited, private ones aren’t.
﻿
//Parent class Dog
class Dog{
    //Declare protected (private) fields
    _attendance = 0;
﻿
    constructor(namee, birthday) {
        this.name = name;
        this.birthday = birthday;
    }
﻿
    getAge() {
        //Getter
        return this.calcAge();
    }
﻿
    calcAge() {
        //calculate age using today's date and birthday
        return this.calcAge();
    }
﻿
    bark() {
        return console.log("Woof!");
    }
﻿
    updateAttendance() {
        //add a day to the dog's attendance days at the petsitters
        this._attendance++;
    }
}
﻿
//instantiate a new instance of Dog class, an individual dog named Rufus
const rufus = new Dog("Rufus", "2/1/2017");
//use getter method to calculate Rufus' age
rufus.getAge();
﻿
Consider the getAge() method in our example code, the calculation details are hidden inside the Dog class. The rufus object uses the getAge() method to calculate Rufus’s age.
﻿
Encapsulating & updating data: Since methods can also update an object’s data, the developer controls what values can be changed through public methods.
﻿
This allows us to hide important information that should not be changed from both phishing and the more likely scenario of other developers mistakenly changing important data.
﻿
Encapsulation adds security to code and makes it easier to collaborate with external developers. When you’re programming to share information with an external company, you wouldn’t want to expose the classes’ templates or private data because your company owns that intellectual property.
﻿
Instead, developers create public methods that allow other developers to call methods on an object. Ideally, these public methods come with documentation for the external developers.
﻿
The benefits of encapsulation are summarized here:
﻿
- Adds security: Only public methods and attributes are accessible from the outside
- Protects against common mistakes: Only public fields & methods accessible, so developers don’t accidentally change something dangerous
- Protects IP: Code is hidden in a class, only public methods are accessible by the outside developers
- Supportable: Most code undergoes updates and improvements
- Hides complexity: No one can see what’s behind the object’s curtain!

16. What is the abstraction in OOP?
﻿
Abstraction means that the user interacts with only selected attributes and methods of an object. Abstraction uses simplified, high level tools, to access a complex object.
﻿
Using simple things to represent complexity
Hide complex details from user
Abstraction is using simple classes to represent complexity. Abstraction is an extension of encapsulation. For example, you don’t have to know all the details of how the engine works to drive a car.
﻿
A driver only uses a small selection of tools: like gas pedal, brake, steering wheel, blinker. The engineering is hidden from the driver. To make a car work, a lot of pieces have to work under the hood, but exposing that information to the driver would be a dangerous distraction.
﻿
Abstraction also serves an important security role. By only displaying selected pieces of data, and only allowing data to be accessed through classes and modified through methods, we protect the data from exposure. To continue with the car example, you wouldn’t want an open gas tank while driving a car.
﻿
The benefits of abstraction are summarized below:
﻿
- Simple, high level user interfaces
- Complex code is hidden
- Security
- Easier software maintenance
- Code updates rarely change abstraction

17. What is Polymorphism in OOP?
﻿
Polymorphism means designing objects to share behaviors. Using inheritance, objects can override shared parent behaviors, with specific child behaviors. Polymorphism allows the same method to execute different behaviors in two ways: method overriding and method overloading.
Method Overriding:
- Runtime polymorphism uses method overriding. In method overriding, a child class can provide a different implementation than its parent class. In our dog example, we may want to give TrackingDog a specific type of bark different than the generic dog class.
﻿
Method overriding could create a bark() method in the child class that overrides the bark() method in the parent Dog class.
//Parent class Dog
class Dog{
    //Declare protected (private) fields
    _attendance = 0;
﻿
    constructor(namee, birthday) {
        this.name = name;
        this.birthday = birthday;
    }
﻿
    getAge() {
        //Getter
        return this.calcAge();
    }
﻿
    calcAge() {
        //calculate age using today's date and birthday
        return this.calcAge();
    }
﻿
    bark() {
        return console.log("Woof!");
    }
﻿
    updateAttendance() {
        //add a day to the dog's attendance days at the petsitters
        this._attendance++;
    }
}
﻿
//Child class TrackingDog, inherits from parent
class TrackingDog extends Dog {
    constructor(name, birthday)
        super(name);
        super(birthday);
    }
﻿
    track() {
        //additional method for TrackingDog child class
        return console.log("Searching...")
    }
﻿
    bark() {
        return console.log("Found it!");
    }
﻿
﻿
//instantiate a new TrackingDog object
const duke = new TrackingDog("Duke", "1/12/2019");
duke.bark(); //returns "Found it!"
﻿
Method Overloading
Compile Time polymorphism uses method overloading. Methods or functions may have the same name, but a different number of parameters passed into the method call. Different results may occur depending on the number of parameters passed in.
﻿
//Parent class Dog
class Dog{
    //Declare protected (private) fields
    _attendance = 0;
﻿
    constructor(namee, birthday) {
        this.name = name;
        this.birthday = birthday;
    }
﻿
    getAge() {
        //Getter
        return this.calcAge();
    }
﻿
    calcAge() {
        //calculate age using today's date and birthday
        return this.calcAge();
    }
﻿
    bark() {
        return console.log("Woof!");
    }
﻿
    updateAttendance() {
        //add a day to the dog's attendance days at the petsitters
        this._attendance++;
    }
﻿
    updateAttendance(x) {
        //adds multiple to the dog's attendance days at the petsitters
        this._attendance = this._attendance + x;
    }
}
﻿
//instantiate a new instance of Dog class, an individual dog named Rufus
const rufus = new Dog("Rufus", "2/1/2017");
rufus.updateAttendance(); //attendance = 1
rufus.updateAttendance(4); // attendance = 5
﻿
In this code example, if no parameters are passed into the updateAttendance() method. One day is added to the count. If a parameter is passed in updateAttendance(4), then 4 is passed into the x parameter in updateAttendance(x), and 4 days are added to the count.
﻿
The benefits of Polymorphism are:
﻿
Objects of different types can be passed through the same interface:
- Method overriding
- Method overloading

18. What is the conclusion about OOP?

Object Oriented programming requires thinking about the structure of the program and planning at the beginning of coding. Looking at how to break up the requirements into simple, reusable classes that can be used to blueprint instances of objects. Overall, implementing OOP allows for better data structures and reusability, saving time in the long run.

19. What is the Singelton Design Pattern?
﻿
The singleton pattern only allows a class or object to have a single instance and it uses a global variable to store that instance. You can use lazy loading to make sure that there is only one instance of the class because it will only create the class when you need it.
﻿
That prevents multiple instances from being active at the same time which could cause weird bugs. Most of the time this gets implemented in the constructor. The goal of the singleton pattern is typically to regulate the global state of an application.
﻿
An example of a singleton that you probably use all the time is your logger.
﻿
If you work with some of the front-end frameworks like React or Angular, you know all about how tricky it can be to handle logs coming from multiple components. This is a great example of singletons in action because you never want more than one instance of a logger object, especially if you're using some kind of error tracking tool.
﻿
class FoodLogger {
  constructor() {
    this.foodLog = []
  }
    
  log(order) {
    this.foodLog.push(order.foodItem)
    // do fancy code to send this log somewhere
  }
}
﻿
// this is the singleton
class FoodLoggerSingleton {
  constructor() {
    if (!FoodLoggerSingleton.instance) {
      FoodLoggerSingleton.instance = new FoodLogger()
    }
  }
  
  getFoodLoggerInstance() {
    return FoodLoggerSingleton.instance
  }
}
﻿
module.exports = FoodLoggerSingleton
﻿
Now you don't have to worry about losing logs from multiple instances because you only have one in your project. So when you want to log the food that has been ordered, you can use the same FoodLogger instance across multiple files or components.
﻿
const FoodLogger = require('./FoodLogger')
﻿
const foodLogger = new FoodLogger().getFoodLoggerInstance()
﻿
class Customer {
  constructor(order) {
    this.price = order.price
    this.food = order.foodItem
    foodLogger.log(order)
  }
  
  // other cool stuff happening for the customer
}
﻿
module.exports = Customer
﻿
const FoodLogger = require('./FoodLogger')
﻿
const foodLogger = new FoodLogger().getFoodLoggerInstance()
﻿
class Restaurant {
  constructor(inventory) {
    this.quantity = inventory.count
    this.food = inventory.foodItem
    foodLogger.log(inventory)
  }
  
  // other cool stuff happening at the restaurant
}
﻿
module.exports = Restaurant
﻿
With this singleton pattern in place, you don't have to worry about just getting the logs from the main application file. You can get them from anywhere in your code base and they will all go to the exact same instance of the logger, which means none of your logs should get lost due to new instances.

20. What is the Strategy Design Pattern?
﻿
The strategy is pattern is like an advanced version of an if else statement.  It's basically where you make an interface for a method you have in your base class. This interface is then used to find the right implementation of that method that should be used in a derived class. The implementation, in this case, will be decided at runtime based on the client.
﻿
This pattern is incredibly useful in situations where you have required and optional methods for a class. Some instances of that class won't need the optional methods, and that causes a problem for inheritance solutions. You could use interfaces for the optional methods, but then you would have to write the implementation every time you used that class since there would be no default implementation.
﻿
That's where the strategy pattern saves us. Instead of the client looking for an implementation, it delegates to a strategy interface and the strategy finds the right implementation. One common use for this is with payment processing systems.
﻿
You could have a shopping cart that only lets customers check out with their credit cards, but you will lose customers that want to use other payment methods.
﻿
The strategy design pattern lets us decouple the payment methods from the checkout process which means we can add or update strategies without changing any code in the shopping cart or checkout process.
﻿
class PaymentMethodStrategy {
﻿
  const customerInfoType = {
    country: string
    emailAddress: string
    name: string
    accountNumber?: number
    address?: string
    cardNumber?: number
    city?: string
    routingNumber?: number
    state?: string
  }
  
  static BankAccount(customerInfo: customerInfoType) {
    const { name, accountNumber, routingNumber } = customerInfo
    // do stuff to get payment
  }
  
  static BitCoin(customerInfo: customerInfoType) {
    const { emailAddress, accountNumber } = customerInfo
    // do stuff to get payment
  }
  
  static CreditCard(customerInfo: customerInfoType) {
    const { name, cardNumber, emailAddress } = customerInfo
    // do stuff to get payment
  }
  
  static MailIn(customerInfo: customerInfoType) {
    const { name, address, city, state, country } = customerInfo
    // do stuff to get payment
  }
  
  static PayPal(customerInfo: customerInfoType) {
    const { emailAddress } = customerInfo
    // do stuff to get payment
  }
}
﻿
To implement our payment method strategy, we made a single class with multiple static methods. Each method takes the same parameter, customerInfo, and that parameter has a defined type of customerInfoType. (Hey all you TypeScript devs! ??) Take note that each method has its own implementation and uses different values from the customerInfo.
﻿
With the strategy pattern, you can also dynamically change the strategy being used at run time. That means you'll be able to change the strategy, or method implementation, being used based on user input or the environment the app is running in.
﻿
You can also set a default implementation in a simple config.json file like this:
﻿
{
  "paymentMethod": {
    "strategy": "PayPal"
  }
}
﻿
Whenever a customer starts going through the checkout process on your website, the default payment method they encounter will be the PayPal implementation which comes from the config.json. This could easily be updated if the customer selects a different payment method.
﻿
Now we'll create a file for our checkout process.
﻿
const PaymentMethodStrategy = require('./PaymentMethodStrategy')
const config = require('./config')
﻿
class Checkout {
  constructor(strategy='CreditCard') {
    this.strategy = PaymentMethodStrategy[strategy]
  }
  
  // do some fancy code here and get user input and payment method
  
  changeStrategy(newStrategy) {
    this.strategy = PaymentMethodStrategy[newStrategy]
  }
  
  const userInput = {
    name: 'Malcolm',
    cardNumber: 3910000034581941,
    emailAddress: 'mac@gmailer.com',
    country: 'US'
  }
  
  const selectedStrategy = 'Bitcoin'
  
  changeStrategy(selectedStrategy)
  
  postPayment(userInput) {
    this.strategy(userInput)
  }
}
﻿
module.exports = new Checkout(config.paymentMethod.strategy)
This Checkout class is where the strategy pattern gets to show off. We import a couple of files so we have the payment method strategies available and the default strategy from the config.
﻿
Then we create the class with the constructor and a fallback value for the default strategy in case there hasn't been one set in the config. Next we assign the strategy value to a local state variable.
﻿
An important method we need to implement in our Checkout class is the ability to change the payment strategy. A customer might change the payment method they want to use and you'll need to be able to handle that. That's what the changeStrategy method is for.
﻿
After you've done some fancy coding and gotten all of the inputs from a customer, then you can update the payment strategy immediately based on their input and it dynamically sets the strategy before the payment is sent for processing.
﻿
At some point you might need to add more payment methods to your shopping cart and all you'll have to do is add it to the PaymentMethodStrategy class. It'll instantly be available anywhere that class is used.
﻿
The strategy design pattern is a powerful one when you are dealing with methods that have multiple implementations. It might feel like you're using an interface, but you don't have to write an implementation for the method every time you call it in a different class. It gives you more flexibility than interfaces.

21. What are the design patterns?
﻿
In software engineering, a design pattern is a general repeatable solution to a commonly occurring problem in software design. A design pattern isn't a finished design that can be transformed directly into code. It is a description or template for how to solve a problem that can be used in many different situations.

22. What are the 3 types of design patterns?
﻿
- BEHAVIORAL
- STRUCTURAL
- CREATIONAL

23. How to organize design patterns?
﻿
We classify design patterns by two criteria:
- PURPOSE: reflects what a pattern does. Patterns can have either creational, structural, or behavioral purpose. Creational patterns concern the process of object creation. Structural patterns deal with the composition of classes or
objects. Behavioral patterns characterize the ways in which classes or objects interact and distribute responsibility. 
- SCOPE: primarily to classes or to objects. Class patterns deal with relationships between classes and their subclasses. These relationships are established through
inheritance, so they are static—fixed at compile-time. Object patterns deal with object relationships, which can be changed at run-time and are more dynamic. Almost
all patterns use inheritance to some extent. So the only patterns labeled "class patterns" are those that focus on class relationships. Note that most patterns are in the Object scope. 

24. What are the behavioral design patterns?
﻿
Behavioral patterns describe interactions between objects and focus on how objects communicate with each other. They can reduce complex flow charts to mere interconnections between objects of various classes. Behavioral patterns are also used to make the algorithm that a class uses simply another parameter that is adjustable at runtime. Behavioral patterns are concerned with algorithms and the assignment of responsibilities between objects. Behavioral patterns describe not just patterns of objects or classes but also the patterns of communication between them. These patterns characterize complex control flow that is difficult to follow at run-time. They shift your focus away from the flow of control to let you concentrate just on the way objects are interconnected. Behavioral class patterns use inheritance to distribute behavior between classes.
The Template Method is the simpler and more common of the two. A template method is an abstract definition of an algorithm. It defines the algorithm step by step. Each step invokes either an abstract operation or a primitive operation. A subclass fleshes out the algorithm by defining the abstract operations. The other behavioral class pattern is Interpreter pattern, which represents a grammar as a class hierarchy and implements an interpreter as an operation on instances of these classes.

25. What are the creational design patterns?
﻿
Creational patterns are used to create objects for a suitable class that serves as a solution for a problem. Generally when instances of several different classes are available. They are particularly useful when you are taking advantage of polymorphism and need to choose between different classes at runtime rather than compile time.
Creational patterns support the creation of objects in a system. Creational patterns allow objects to be created in a system without having to identify a specific class type in the code, so you do not have to write large, complex code to instantiate an object. It does this by having the subclass of the class create the objects. However, this can limit the type or number of objects that can be created within a system.

26. What are the structural design patterns?
﻿
Structural patterns form larger structures from individual parts, generally of different classes.
Structural patterns vary a great deal depending on what sort of structure is being created for what purpose.
Structural patterns are concerned with how classes and objects are composed to form larger structures.
Structural class patterns use inheritance to compose interfaces or implementations. As a simple example, consider how multiple inheritance mixes two or more classes into one. The result is a class that combines the properties of its parent classes. This pattern is particularly useful for making independently developed class libraries work together. Another example is the class form of the Adapter Pattern. In general, an adapter makes one interface (the adaptee's) conform to another, thereby providing a uniform abstraction of different interfaces. A class adapter accomplishes this by inheriting privately from an adaptee class. The adapter then expresses its interface in terms of the adaptee's.
The link below will reinforce your knowledge of the three types of design patterns.

27. What it is important to study design patterns?
﻿
- Experts in software architecture and design are highly paid, because they know how to create designs that are flexible, elegant, and reusable.
- You become an expert through experience, reusing solutions that worked for you before.
- Patterns describe solutions to design problems that occur over and over again.
- Patterns also record design decisions, alternatives, and trade-offs gained from experience.
- Once you know the pattern, many design decisions follow.
- Knowing patterns helps you get designs right faster.
- Knowing the vocabulary surrounding patterns helps communication between designers, and can ease the documentation effort.

28. How to choose the right design pattern?
﻿
A key misconception in today's coding world is that patterns are building blocks. You take an AbstractFactory here and a Flyweight there and maybe a Singleton over there and connect them together with XML and presto, you've got a working application.
﻿
Patterns are not building blocks
﻿
A pattern is something that you use when you find that you've got a problem - you need some flexibility that the pattern provides, or that you've stumbled across when you are making a little language in the config file and you say "wait a moment, stop, this is its own interpreter that I'm writing - this is a known and solved problem, use an Interpreter pattern."
﻿
But note there, that it's something that you discover in your code, not something you start out with. The creators of Java didn't say "Oh, we'll put a Flyweight in the Integer" at the start, but rather realized a performance issue that could be solved by a flyweight.
﻿
And thus, there's no "flow chart" that you use to find the right pattern. The pattern is a solution to a specific type of problem that has been encountered again and again and the key parts of it distilled into a Pattern.
﻿
Starting out with the Pattern is like having a solution and looking for a problem. This is a bad thing: it leads to over engineering and ultimately inflexibility in design.
﻿
As you are writing code, when you realize that you're writing a Factory, you can say "ah ha! that's a factory I'm about to write" and use your knowledge of knowing the Factory pattern to rapidly write the next bit of code without trying to rediscover the Factory pattern. But you don't start out with "I've got a class here, I'll write a factory for it so that it can be flexible" — because it won't.
﻿
Here's an excerpt from an interview with Erich Gamma (of Gamma, Helm, Johnson, and Vissides): How to Use Design Patterns:
﻿
"Trying to use all the patterns is a bad thing, because you will end up with synthetic designs—speculative designs that have flexibility that no one needs. These days software is too complex. We can't afford to speculate what else it should do. We need to really focus on what it needs. That's why I like refactoring to patterns. People should learn that when they have a particular kind of problem or code smell, as people call it these days, they can go to their patterns toolbox to find a solution."
﻿
The best help for the "what to use, when" is likely the Wikipedia page for software design pattern - the "Classification and list" section describes the category each pattern is in and what it does. There's no flowchart; the description there is probably the best you'll find as a short snippet for "what to use, when."
﻿
Note that you'll find different patterns in different areas of programming. Web design has its own set of patterns while JEE (not web design) has another set of patterns. The patterns for financial programming are completely different to those for stand alone application UI design.
﻿
So any attempt to list them all is inherently incomplete. You find one, figure out how to use it and then it eventually becomes second nature and you don't need to think about how or when to use it ever again.

29. How design patterns solve design problems?
﻿
Design patterns help you choose design alternatives that make a system reusable and avoid alternatives that compromise reusability. Design patterns can even improve the documentation and maintenance of existing systems by furnishing an explicit specification of class and object interactions and their underlying intent. Design patterns provide general solutions, documented in a format that doesn't require specifics tied to a particular problem. In addition, patterns allow developers to communicate using well-known, well understood names for software interactions.

30. Which design pattern should you use and when?
﻿
There's no one right answer for when a particular design or design pattern should be used, you need to build up experience in using and implementing them in order to know when and where to use which pattern. Experience. Learn the patterns and real-world examples of their uses.

31. GLOSSARY:
﻿
-subclass: a class that inherits from another class. In C++, a subclass is called a derived class.
- subsystem: an independent group of classes that collaborate to fulfill a set of responsibilities.
- subtype: a type is a subtype of another if its interface contains the interface of the other type.
- supertype: the parent type from which a type inherits.
- toolkit: a collection of classes that provides useful functionality but does not define the design of an application.
- type: the name of a particular interface.
- white-box reuse: a style of reuse based on class inheritance. A subclass reuses the
interface and implementation of its parent class, but it may have access to otherwise private aspects of its parent.
- parameterized type: a type that leaves some constituent types unspecified. The unspecified types are supplied as parameters at the point of use. In C++, parameterized
types are called templates.
- parent class: the class from which another class inherits. Synonyms are superclass (Smalltalk), base class (C++), and ancestor class.
- polymorphism: the ability to substitute objects of matching interface for one another at run-time.
- private inheritance: in C++, a class inherited solely for its implementation.
- protocol: extends the concept of an interface to include the allowable sequences of requests.
- receiver: the target object of a request.
request. An object performs an operation when it receives a corresponding request from another object. A common synonym for request is message.
- signature: an operation's signature defines its name, parameters, and return value.
- metaclass: classes are objects in Smalltalk. A metaclass is the class of a class object.
- mixin class: a class designed to be combined with other classes through inheritance. Mixin classes are usually abstract.
- object: a run-time entity that packages both data and the procedures that operate on that data.
- object composition: assembling or composing objects to get more complex behavior.
- object diagram: a diagram that depicts a particular object structure at run-time.
- object reference: a value that identifies another object.
operation. An object's data can be manipulated only by its operations. An object performs an operation when it receives a request. In C++, operations are
called member functions. Smalltalk uses the term method.
- overriding: redefining an operation (inherited from a parent class) in a subclass.
- framework: a set of cooperating classes that makes up a reusable design for a specific class of software. A framework provides architectural guidance by partitioning the design into abstract classes and defining their
responsibilities and collaborations. A developer customizes the framework to a particular application by subclassing and composing instances of framework classes.
- friend class: in C++, a class that has the same access rights to the operations and data of a class as that class itself.
- inheritance: a relationship that defines one entity in terms of another. Class inheritance defines a new class in terms of one or more parent classes. The new class inherits its interface and implementation from its parents.
The new class is called a subclass or (in C++) a derived class. Class inheritance combines interface inheritance and implementation inheritance. Interface inheritance defines a new interface in terms of one or more existing interfaces. Implementation inheritance defines a new implementation in terms of one or more existing implementations.
- instance variable: a piece of data that defines part of an object's representation. C++ uses the term data member.
- interaction diagram: a diagram that shows the flow of requests between objects.
- interface: the set of all signatures defined by an object's operations. The interface describes the set of requests to which an object can respond.
- design pattern: a design pattern systematically names, motivates, and explains a general design that addresses a recurring design problem in object-oriented
systems. It describes the problem, the solution, when to apply the solution, and its consequences. It also gives implementation hints and examples. The solution is a general arrangement of objects and classes that solve the
problem. The solution is customized and implemented to solve the problem in a particular context.
- destructor: in C++, an operation that is automatically invoked to finalize an object that is about to be deleted.
- dynamic binding: the run-time association of a request to an object and one of its
operations. In C++, only virtual functions are dynamically bound.
- encapsulation: the result of hiding a representation and implementation in an object. The representation is not visible and cannot be accessed directly from outside the object. Operations are the only way to access and modify an object's representation.
- black-box reuse: a style of reuse based on object composition. Composed objects reveal no internal details to each other and are thus analogous to "black boxes."
- class: a class defines an object's interface and implementation. It specifies the object's internal representation and defines the operations the object
can perform.
- class diagram: a diagram that depicts classes, their internal structure and operations, and the static relationships between them.
- class operation: an operation targeted to a class and not to an individual object. In C++, class operations are are called static member functions.
- concrete class: A class having no abstract operations. It can be instantiated.
- constructor: In C++, an operation that is automatically invoked to initialize new instances.
- coupling: The degree to which software components depend on each other.
- delegation: an implementation mechanism in which an object forwards or delegates a request to another object. The delegate carries out the request on behalf
of the original object.
- abstract class: a class whose primary purpose is to define an interface. An abstract class defers some or all of its implementation to subclasses. An abstract
class cannot be instantiated.
- abstract coupling: given a class A that maintains a reference to an abstract class B, class A is said to be abstractly coupled to B. We call this abstract coupling
because A refers to a type of object, not a concrete object.
- abstract operation: an operation that declares a signature but doesn't implement it. In
C++, an abstract operation corresponds to a pure virtual member function.
- acquaintance relationship: aclass that refers to another class has an acquaintance with that class.
- aggregate object: an object that's composed of subobjects. The subobjects are called the
aggregate's parts, and the aggregate is responsible for them.
- aggregation relationship: the relationship of an aggregate object to its parts. A class defines
this relationship for its instances (e.g., aggregate objects).



